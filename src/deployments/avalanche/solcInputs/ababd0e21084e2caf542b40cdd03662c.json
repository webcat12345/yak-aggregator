{
  "language": "Solidity",
  "sources": {
    "contracts/adapters/CurveLikeAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\nimport \"../interface/ICurveLikePool.sol\";\nimport \"../interface/IERC20.sol\";\nimport \"../interface/IWETH.sol\";\nimport \"../YakAdapter.sol\";\n\ncontract CurveLikeAdapter is YakAdapter {\n\n    mapping (address => bool) public TOKENS_MAP;\n\n    constructor (string memory _name, address _router, uint8 tokenCount) {\n        name = _name;\n        router = _router;\n\n        setPoolTokens(tokenCount);\n    }\n\n    // Mapping indicator which tokens are included in the pool \n    function setPoolTokens(uint8 tokenCount) internal {\n        for (uint8 index=0; index<tokenCount; index++) {\n            IERC20 token = ICurveLikePool(router).getToken(index);\n            TOKENS_MAP[address(token)] = true;\n        }\n    }\n\n    function setAllowances() public override onlyOwner {}\n\n    function query(uint amountIn, address tokenIn, address tokenOut) external override view returns (uint) {\n        address[] memory path = new address[](2);\n        path[0] = tokenIn;\n        path[1] = tokenOut;\n        if (tokenIn==tokenOut) { return 0; }\n        // Cancel query if pool is closed\n        if (ICurveLikePool(router).paused() || amountIn==0) { return 0; }\n        // Cancel query if tokens not in the pool\n        if (!TOKENS_MAP[tokenIn] || !TOKENS_MAP[tokenOut]) { return 0; }\n        uint tokenIndexIn = ICurveLikePool(router).getTokenIndex(tokenIn);\n        uint tokenIndexOut = ICurveLikePool(router).getTokenIndex(tokenOut);\n        uint amountOut = ICurveLikePool(router).calculateSwap(\n            uint8(tokenIndexIn), \n            uint8(tokenIndexOut), \n            amountIn\n        );\n        return amountOut;\n    }\n\n    function _swap(uint amountIn, address[] calldata path, uint amountOutMin) internal override {\n        ICurveLikePool(router).swap(\n            ICurveLikePool(router).getTokenIndex(path[0]), \n            ICurveLikePool(router).getTokenIndex(path[1]), \n            amountIn, \n            amountOutMin, \n            block.timestamp\n        );\n    }\n\n}"
    },
    "contracts/interface/ICurveLikePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\nimport \"./IERC20.sol\";\n\ninterface ICurveLikePool {\n\n    function getTokenIndex(address tokenAddress) external view returns (uint8);\n    function getTokenBalance(uint8 index) external view returns (uint256);\n    function getToken(uint8 index) external view returns (IERC20);\n    function getVirtualPrice() external view returns (uint256);\n    function owner() external view returns (address);\n    function paused() external view returns (bool);\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function unpause() external;\n    function pause() external;\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256);\n\n}"
    },
    "contracts/interface/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\ninterface IERC20 {\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function symbol() external view returns (string memory);\n    function name() external view returns (string memory);\n    function nonces(address) external view returns (uint);\n    function totalSupply() external view returns (uint);\n    function decimals() external view returns (uint8);\n    \n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function balanceOf(address owner) external view returns (uint);\n    \n}"
    },
    "contracts/interface/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\ninterface IWETH {\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function allowance(address owner, address spender) external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function symbol() external view returns (string memory);\n    function name() external view returns (string memory);\n    function totalSupply() external view returns (uint);\n    function decimals() external view returns (uint8);\n\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function withdraw(uint256 amount) external;\n    function deposit() external payable;\n    \n}"
    },
    "contracts/YakAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\nimport \"./interface/IERC20.sol\";\nimport \"./interface/IWETH.sol\";\nimport \"./lib/Ownable.sol\";\n\nabstract contract YakAdapter is Ownable {\n\n    address internal constant WAVAX = 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7;\n    address internal constant AVAX = address(0);\n    uint internal constant UINT_MAX = uint(-1);\n\n    address public router;\n    string public name;\n\n    /**\n     * @notice Approve tokens for use in Strategy\n     * @dev Should use modifier `onlyOwner` to avoid griefing\n     */\n    function setAllowances() public virtual;\n\n    /**\n     * @notice Revoke token allowance\n     * @param token address\n     * @param spender address\n     */\n    function revokeAllowance(address token, address spender) external onlyOwner {\n        require(IERC20(token).approve(spender, 0));\n    }\n\n    function getBalance(\n        address asset, \n        address holder\n    ) public view returns (uint256) {\n        if (asset==AVAX) {\n            return holder.balance;\n        }\n        return IERC20(asset).balanceOf(holder);\n    }\n\n    /**\n     * @notice Recover ERC20 from contract\n     * @param tokenAddress token address\n     * @param tokenAmount amount to recover\n     */\n    function recoverERC20(address tokenAddress, uint tokenAmount) external onlyOwner {\n        require(tokenAmount > 0);\n        require(IERC20(tokenAddress).transfer(msg.sender, tokenAmount));\n    }\n\n    /**\n     * @notice Recover AVAX from contract\n     * @param amount amount\n     */\n    function recoverAVAX(uint amount) external onlyOwner {\n        require(amount > 0);\n        payable(msg.sender).transfer(amount);\n    }\n\n    function query(uint amountIn, address tokenIn, address tokenOut) external virtual view returns (uint);\n\n    /**\n     * Execute a swap from token to AVAX\n     * @notice Interact directly through adapter\n     * @param path set of addresses\n     * @param amountOutMin amount\n     * @param to address where swapped funds should be sent to\n     */\n    function swapFromAvaxToToken(\n            address[] calldata path, \n            uint amountOutMin, \n            address payable to\n        ) external payable {\n            require(path[0] == WAVAX, \"YakAdapter::swap - must start with AVAX\");\n            require(path.length == 2, \"YakAdapter::swap - invalid path\");\n            _wrap(msg.value);\n            _approveIfNeeded(path, msg.value);\n            _swap(msg.value, path, amountOutMin);\n            address _tokenOut = path[path.length - 1];\n            uint tknBal = IERC20(_tokenOut).balanceOf(address(this));\n            require(tknBal>=amountOutMin, 'YakAdapter::swap - Insufficient out amount');\n            _returnTo(_tokenOut, tknBal, to);\n    }\n\n    /**\n     * Execute a swap from token to AVAX\n     * @notice Interact directly through adapter\n     * @param path set of addresses\n     * @param amountOutMin amount\n     * @param to address where swapped funds should be sent to\n     */\n    function swapFromTokenToAvax(\n            uint amountIn, \n            address[] calldata path, \n            uint amountOutMin, \n            address payable to\n        ) external {\n            require(path[path.length-1] == WAVAX, \"YakAdapter::swap - must end with AVAX\");\n            require(path.length == 2, \"YakAdapter::swap - invalid path\");\n            IERC20(path[0]).transferFrom(msg.sender, address(this), amountIn);\n            _approveIfNeeded(path, amountIn);\n            _swap(amountIn, path, amountOutMin);\n            address _tokenOut = path[path.length - 1];\n            uint tknBal = IERC20(_tokenOut).balanceOf(address(this));\n            require(tknBal>=amountOutMin, 'YakAdapter::swap - Insufficient out amount');\n            _returnTo(AVAX, tknBal, to);\n    }\n\n    /**\n     * Execute a swap from token to token\n     * @notice Interact directly through adapter\n     * @param amountIn input amount in starting token\n     * @param path set of addresses\n     * @param amountOutMin min amount out in ending token\n     * @param to address where swapped funds should be sent to\n     */\n    function swapFromTokenToToken(\n            uint amountIn, \n            address[] calldata path,\n            uint amountOutMin,\n            address payable to\n        ) external {\n            require(path.length == 2, \"YakAdapter::swap - invalid path\");\n            IERC20(path[0]).transferFrom(msg.sender, address(this), amountIn);\n            _approveIfNeeded(path, amountIn);\n            _swap(amountIn, path, amountOutMin);\n            address _tokenOut = path[path.length - 1];\n            uint tknBal = IERC20(_tokenOut).balanceOf(address(this));\n            require(tknBal>=amountOutMin, 'YakAdapter::swap - Insufficient out amount');\n            _returnTo(_tokenOut, tknBal, to);\n    }\n\n    /**\n     * Execute a swap from token to token assuming this contract already holds input tokens\n     * @notice Interact through the router\n     * @param amountIn input amount in starting token\n     * @param path set of addresses\n     * @param amountOutMin min amount out in ending token\n     * @param to address where swapped funds should be sent to\n     */\n    function swapFromTokenToTokenWithoutTransfer(\n            uint amountIn, \n            address[] calldata path, \n            uint amountOutMin,\n            address payable to\n        ) external {\n            require(path.length == 2, \"YakAdapter::swap - invalid path\");\n            _approveIfNeeded(path, amountIn);\n            _swap(amountIn, path, amountOutMin);\n            address _tokenOut = path[path.length - 1];\n            uint tknBal = IERC20(_tokenOut).balanceOf(address(this));\n            require(tknBal>=amountOutMin, 'YakAdapter::swap - Insufficient out amount');\n            _returnTo(_tokenOut, tknBal, to);\n    }\n\n    /**\n     * @notice Internal implementation of a swap\n     * @dev Must return tokens to address(this)\n     * @dev Wrapping is handled external to this function\n     * @param amountIn amount\n     * @param path addresses\n     * @param amountOutMin amount\n     */\n    function _swap(uint amountIn, address[] calldata path, uint amountOutMin) internal virtual;\n\n    function _approveIfNeeded(address[] calldata path, uint amount) internal {\n        uint allowance = IERC20(path[0]).allowance(address(this), router);\n        if (allowance < amount) {\n            require(IERC20(path[0]).approve(router, UINT_MAX), \"YakAdapter::_approveIfNeeded\");\n        }\n    }\n\n    /**\n     * @notice Return expected funds to user\n     * @dev Pass address(0) for AVAX\n     * @param token address\n     * @param amount tokens to return\n     * @param to address where funds should be sent to\n     */\n    function _returnTo(address token, uint amount, address payable to) internal {\n        if (address(this)!=to) {\n            if (token == AVAX) {\n                _unwrap(amount);\n                to.transfer(amount);\n            } else {\n                require(IERC20(token).transfer(to, amount), \"YakAdapter::_return, token\");\n            }\n        }\n    }\n\n    /**\n     * @notice Wrap AVAX\n     * @param amount amount\n     */\n    function _wrap(uint amount) internal {\n        IWETH(WAVAX).deposit{value: amount}();\n    }\n\n    /**\n     * @notice Unwrap WAVAX\n     * @param amount amount\n     */\n    function _unwrap(uint amount) internal {\n        IWETH(WAVAX).withdraw(amount);\n    }\n\n    receive() external payable {}\n}"
    },
    "contracts/lib/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0;\n\nimport \"./Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/lib/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return payable(msg.sender);\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/adapters/SushiswapAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\nimport \"../interface/IUnilikeETHRouter.sol\";\nimport \"../interface/IERC20.sol\";\nimport \"../interface/IWETH.sol\";\nimport \"../YakAdapter.sol\";\n\ncontract SushiswapAdapter is YakAdapter {\n\n    constructor (string memory _name, address _router) {\n        name = _name;\n        router = _router;\n        setAllowances();\n    }\n\n    function setAllowances() public override onlyOwner {\n        IERC20(WAVAX).approve(WAVAX, UINT_MAX);\n    }\n\n    // TODO: Get rid of path and use calldata\n    function query(uint amountIn, address tokenIn, address tokenOut) external override view returns (uint) {\n        address[] memory path = new address[](2);\n        path[0] = tokenIn;\n        path[1] = tokenOut;\n        if (tokenIn == tokenOut) { return 0; }\n        try IUnilikeETHRouter(router).getAmountsOut(\n            amountIn, path\n        ) returns (uint[] memory amounts) {\n            return amounts[1];\n        } catch {\n            return 0;\n        }\n    }\n\n    function _swap(uint amountIn, address[] calldata path, uint amountOutMin) internal override {\n        IUnilikeETHRouter(router).swapExactTokensForTokens(\n            amountIn,\n            amountOutMin,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n}"
    },
    "contracts/interface/IUnilikeETHRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\ninterface IUnilikeETHRouter {\n\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}"
    },
    "contracts/YakRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./lib/BytesManipulation.sol\";\nimport \"./interface/IAdapter.sol\";\nimport \"./interface/IERC20.sol\";\nimport \"./interface/IWETH.sol\";\nimport \"./lib/Ownable.sol\";\n\ncontract YakRouter is Ownable {\n\n    address public constant WAVAX = 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7;\n    address public constant AVAX = address(0);\n    uint public slippageDenominator = 100000;\n    string public constant name = 'YakRouter';\n    uint8 public maxSteps; \n    address[] public trustedTokens;\n    address[] public adapters;\n\n    struct Query {\n        address adapter;\n        address tokenIn;\n        address tokenOut;\n        uint256 amountOut;\n    }\n\n    struct Queries {\n        bytes amounts;\n        bytes adapters;\n        bytes path;\n    }\n\n    struct FormattedQueries {\n        uint256[] amounts;\n        address[] adapters;\n        address[] path;\n    }\n\n    constructor(\n        address[] memory _adapters,\n        address[] memory _trustedTokens,\n        uint8 _maxSteps \n    ) {\n        trustedTokens = _trustedTokens;\n        adapters = _adapters;\n        maxSteps = _maxSteps;\n    }\n\n\n    // -- GENERAL --\n\n\n    function setMaxSteps(uint8 _maxSteps) public onlyOwner {\n        maxSteps = _maxSteps;\n    }\n\n    function setTrustedTokens(\n            address[] calldata _trustedTokens\n        ) public onlyOwner {\n            trustedTokens = _trustedTokens;\n    }\n\n    function setAdapters(\n            address[] calldata _adapters\n        ) public onlyOwner {\n            adapters = _adapters;\n    }\n\n    function trustedTokensCount() external view returns (uint) {\n        return trustedTokens.length;\n    }\n\n    function adaptersCount() external view returns (uint) {\n        return adapters.length;\n    }\n\n    function approveTokenForSpender(\n            address token, \n            address spender,\n            uint256 amount\n        ) public onlyOwner {\n            IERC20(token).approve(spender, amount);\n    }\n\n    function recoverERC20(address tokenAddress, uint tokenAmount) external onlyOwner {\n        require(tokenAmount > 0);\n        require(IERC20(tokenAddress).transfer(msg.sender, tokenAmount));\n    }\n\n    function recoverAVAX(uint amount) external onlyOwner {\n        require(amount > 0);\n        payable(msg.sender).transfer(amount);\n    }\n\n    // Fallback\n    receive() external payable {}\n\n\n    // -- HELPERS -- \n\n\n    function getBalance(\n        address asset, \n        address holder\n    ) public view returns (uint256) {\n        if (asset==AVAX) {\n            return holder.balance;\n        }\n        return IERC20(asset).balanceOf(holder);\n    }\n\n    function _wrap(uint amount) internal {\n        IWETH(WAVAX).deposit{value: amount}();\n    }\n\n    function _unwrap(uint amount) internal {\n        IWETH(WAVAX).withdraw(amount);\n    }\n\n    function staticSlice(\n            address[] memory sArray, \n            uint fromIndex, \n            uint toIndex\n        ) internal pure returns (address[] memory slicedArray) {\n            slicedArray = new address[](toIndex - fromIndex);\n            for (uint i=fromIndex; i<toIndex; i++) {\n                slicedArray[i-fromIndex] = sArray[i];\n            }\n    }\n\n    /**\n     * @notice Return tokens to user\n     * @dev Pass address(0) for AVAX\n     * @param token address\n     * @param amount tokens to return\n     * @param to address where funds should be sent to\n     */\n    function _returnTokensTo(address token, uint amount, address to) internal {\n        if (address(this)!=to) {\n            if (token == AVAX) {\n                _unwrap(amount);\n                payable(to).transfer(amount);\n            } else {\n                require(IERC20(token).transfer(to, amount), \"YakAdapter::_return, token\");\n            }\n        }\n    }\n\n    /**\n     * Makes a deep copy of Queries struct\n     */\n    function cloneQueries(\n        Queries memory queries\n    ) internal pure returns (Queries memory) {\n        return Queries(\n            queries.amounts, \n            queries.adapters, \n            queries.path\n        );\n    }\n\n    /**\n     * Appends Query elements to Queries struct\n     */\n    function addQuery(\n            Queries memory queries, \n            uint256 amount, \n            address adapter, \n            address tokenOut\n        ) internal pure {\n            queries.path = BytesManipulation.mergeBytes(queries.path, BytesManipulation.toBytes(tokenOut));\n            queries.amounts = BytesManipulation.mergeBytes(queries.amounts, BytesManipulation.toBytes(amount));\n            queries.adapters = BytesManipulation.mergeBytes(queries.adapters, BytesManipulation.toBytes(adapter));\n    }\n\n    /**\n     * Converts byte-arrays to an array of integers\n     */\n    function formatAmounts(bytes memory _amounts) public pure returns (uint256[] memory) {\n        // Format amounts\n        uint256 chunks = _amounts.length / 32;\n        uint256[] memory amountsFormatted = new uint256[](chunks);\n        for (uint256 i=0; i<chunks; i++) {\n            amountsFormatted[i] = BytesManipulation.bytesToUint256(i*32+32, _amounts);\n        }\n        return amountsFormatted;\n    }\n\n    /**\n     * Converts byte-array to an array of addresses\n     */\n    function formatAddresses(bytes memory _addresses) public pure returns (address[] memory) {\n        uint256 chunks = _addresses.length / 32;\n        address[] memory addressesFormatted = new address[](chunks);\n        for (uint256 i=0; i<chunks; i++) {\n            addressesFormatted[i] = BytesManipulation.bytesToAddress(i*32+32, _addresses);\n        }\n        return addressesFormatted;\n    }\n\n    /**\n     * Formats elements in the Queries object from byte-arrays to integers and addresses\n     */\n    function formatQueries(Queries memory queries) public pure returns (FormattedQueries memory) {\n        return FormattedQueries(\n            formatAmounts(queries.amounts), \n            formatAddresses(queries.adapters), \n            formatAddresses(queries.path)\n        );\n    }\n\n\n    // -- QUERIES --\n\n\n    /**\n     * Query single adapter\n     */\n    function queryAdapter(\n            uint256 amountIn, \n            address tokenIn, \n            address tokenOut,\n            uint8 index\n        ) external view returns (string memory, uint256){\n            IAdapter _adapter = IAdapter(adapters[index]);\n            uint amountOut = _adapter.query(amountIn, tokenIn, tokenOut);\n            return (_adapter.name(), amountOut);\n    }\n\n    /**\n     * Query specified adapters\n     */\n    function queryNoSplit(\n            uint256 amountIn, \n            address tokenIn, \n            address tokenOut,\n            uint8[] calldata options\n        ) public view returns (Query memory) {\n            Query memory bestQuery;\n            for (uint8 i; i<options.length; i++) {\n                address _adapter = adapters[options[i]];\n                uint amountOut = IAdapter(_adapter).query(\n                    amountIn, \n                    tokenIn, \n                    tokenOut\n                );\n                if (i==0 || amountOut>bestQuery.amountOut) {\n                    bestQuery = Query(_adapter, tokenIn, tokenOut, amountOut);\n                }\n            }\n            return bestQuery;\n    }\n\n    /**\n     * Query all adapters\n     */\n    function queryNoSplit(\n            uint256 amountIn, \n            address tokenIn, \n            address tokenOut\n        ) public view returns (Query memory) {\n            Query memory bestQuery;\n            for (uint8 i; i<adapters.length; i++) {\n                address _adapter = adapters[i];\n                uint amountOut = IAdapter(_adapter).query(\n                    amountIn, \n                    tokenIn, \n                    tokenOut\n                );\n                if (i==0 || amountOut>bestQuery.amountOut) {\n                    bestQuery = Query(_adapter, tokenIn, tokenOut, amountOut);\n                }\n            }\n            return bestQuery;\n    }\n\n    /**\n     * Return path with best returns between two tokens\n     */\n    function findBestPath(\n            uint256 amountIn, \n            address tokenIn, \n            address tokenOut\n        ) external view returns (FormattedQueries memory) {\n            Queries memory queries;\n            queries.amounts = BytesManipulation.toBytes(amountIn);\n            queries.path = BytesManipulation.toBytes(tokenIn);\n            queries = _findBestPath(amountIn, tokenIn, tokenOut, queries);\n            // If no paths are found return empty struct\n            if (queries.adapters.length==0) {\n                queries.amounts = '';\n                queries.path = '';\n            }\n            return formatQueries(queries);\n    } \n\n    function _findBestPath(\n            uint256 amountIn, \n            address tokenIn, \n            address tokenOut, \n            Queries memory queries\n        ) internal view returns (Queries memory) {\n            Queries memory bestOption = cloneQueries(queries);\n            uint256 bestAmountOut;\n            // First check if there is a path directly from tokenIn to tokenOut\n            Query memory queryDirect = queryNoSplit(amountIn, tokenIn, tokenOut);\n            if (queryDirect.amountOut!=0) {\n                addQuery(bestOption, queryDirect.amountOut, queryDirect.adapter, queryDirect.tokenOut);\n                bestAmountOut = queryDirect.amountOut;\n            }\n            // Only check the rest if they would go beyond step limit (Need at least 2 more steps)\n            if (maxSteps>=1 && queries.adapters.length/32<=maxSteps-2) {\n                // Check for paths that pass through trusted tokens\n                for (uint256 i=0; i<trustedTokens.length; i++) {\n                    if (tokenIn == trustedTokens[i]) {\n                        continue;\n                    }\n                    // Loop through all adapters to find the best one for swapping tokenIn for one of the trusted tokens\n                    Query memory bestSwap = queryNoSplit(amountIn, tokenIn, trustedTokens[i]);\n                    if (bestSwap.amountOut==0) {\n                        continue;\n                    }\n                    // Explore options that connect the current path to the tokenOut\n                    Queries memory newQueries = cloneQueries(queries);\n                    addQuery(newQueries, bestSwap.amountOut, bestSwap.adapter, bestSwap.tokenOut);\n                    newQueries = _findBestPath(bestSwap.amountOut, trustedTokens[i], tokenOut, newQueries);  // Recursive step\n                    address _tokenOut = BytesManipulation.bytesToAddress(newQueries.path.length, newQueries.path);\n                    uint256 _amountOut = BytesManipulation.bytesToUint256(newQueries.amounts.length, newQueries.amounts);\n                    // Check that the last token in the path is the tokenOut and update the new best option if neccesary\n                    if (_tokenOut == tokenOut && _amountOut>bestAmountOut) {\n                        bestAmountOut = _amountOut;\n                        bestOption = newQueries;\n                    }\n                }\n            }\n            return bestOption;   \n    }\n\n\n    // -- SWAPPERS --\n\n\n    function _swapNoSplit(\n        uint256[] calldata amounts, \n        address[] calldata _adapters, \n        address[] calldata path,\n        uint slippage\n    ) internal returns (uint) {\n        uint amountOutMin;\n        uint expectedOutAmount;\n        for (uint256 i=0; i<_adapters.length; i++) {\n            // All adapters should transfer output token to the following target\n            // All targets are the adapters, expect for the last swap where tokens are sent out\n            address targetAddress = i<_adapters.length-1 ? _adapters[i+1] : address(this);\n            // Slice the static path\n            uint256 amountIn = getBalance(path[i], _adapters[i]);\n            expectedOutAmount = amounts[i+1];\n            amountOutMin = expectedOutAmount*(slippageDenominator-slippage)/slippageDenominator;\n            IAdapter(_adapters[i]).swapFromTokenToTokenWithoutTransfer(\n                amountIn, \n                staticSlice(path, i, i+2),\n                amountOutMin, \n                targetAddress\n            );\n        }\n        // Calculate how much should be returned to the user\n        uint tknBal = getBalance(path[path.length-1], address(this));\n        uint returnAmount = tknBal < expectedOutAmount ? tknBal : expectedOutAmount;\n        return returnAmount;\n    }\n\n    function swapNoSplit(\n        uint256[] calldata amounts, \n        address[] calldata _adapters, \n        address[] calldata path, \n        uint256 slippage\n    ) public {\n        IERC20(path[0]).transferFrom(msg.sender, _adapters[0], amounts[0]);\n        uint returnAmount = _swapNoSplit(amounts, _adapters, path, slippage);\n        _returnTokensTo(path[path.length-1], returnAmount, msg.sender);\n    }\n\n    function swapNoSplitFromAVAX(\n        uint256[] calldata amounts, \n        address[] calldata _adapters, \n        address[] calldata path,\n        uint256 slippage\n    ) external payable {\n        require(path[0]==WAVAX, 'Path needs to begin with WAVAX');\n        _wrap(amounts[0]);\n        IERC20(path[0]).transferFrom(address(this), _adapters[0], amounts[0]);\n        uint returnAmount = _swapNoSplit(amounts, _adapters, path, slippage);\n        _returnTokensTo(path[path.length-1], returnAmount, msg.sender);\n    }\n\n    function swapNoSplitToAVAX(\n        uint256[] calldata amounts, \n        address[] calldata _adapters, \n        address[] calldata path,\n        uint256 slippage\n    ) public {\n        require(path[path.length-1]==WAVAX, 'Path needs to end with WAVAX');\n        IERC20(path[0]).transferFrom(msg.sender, _adapters[0], amounts[0]);\n        uint returnAmount = _swapNoSplit(amounts, _adapters, path, slippage);\n        _returnTokensTo(AVAX, returnAmount, msg.sender);\n    }\n\n    /**\n     * Swap token to token without the need to approve the first token\n     */\n    function swapNoSplitWithPermit(\n        uint256[] calldata amounts, \n        address[] calldata _adapters, \n        address[] calldata path, \n        uint256 slippage, \n        uint deadline, \n        uint8 v,\n        bytes32 r, \n        bytes32 s\n    ) external {\n        IERC20(path[0]).permit(msg.sender, address(this), amounts[0], deadline, v, r, s);\n        swapNoSplit(amounts, _adapters, path, slippage);\n    } \n\n    /**\n     * Swap token to AVAX without the need to approve the first token\n     */\n    function swapNoSplitToAVAXWithPermit(\n        uint256[] calldata amounts, \n        address[] calldata _adapters, \n        address[] calldata path,\n        uint256 slippage,\n        uint deadline, \n        uint8 v,\n        bytes32 r, \n        bytes32 s\n    ) external {\n        IERC20(path[0]).permit(msg.sender, address(this), amounts[0], deadline, v, r, s);\n        swapNoSplitToAVAX(amounts, _adapters, path, slippage);\n    }\n\n}"
    },
    "contracts/lib/BytesManipulation.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\nimport \"./BytesToTypes.sol\";\n\nlibrary BytesManipulation {\n\n    function toBytes(uint256 x) internal pure returns (bytes memory b) {\n        b = new bytes(32);\n        assembly { mstore(add(b, 32), x) }\n    }\n\n    function toBytes(address x) internal pure returns (bytes memory b) {\n        b = new bytes(32);\n        assembly { mstore(add(b, 32), x) }\n    }\n\n    function mergeBytes(bytes memory a, bytes memory b) public pure returns (bytes memory c) {\n        uint alen = a.length;\n        uint totallen = alen + b.length;\n        uint loopsa = (a.length + 31) / 32;\n        uint loopsb = (b.length + 31) / 32;\n        assembly {\n            let m := mload(0x40)\n            mstore(m, totallen)\n            for {  let i := 0 } lt(i, loopsa) { i := add(1, i) } { mstore(add(m, mul(32, add(1, i))), mload(add(a, mul(32, add(1, i))))) }\n            for {  let i := 0 } lt(i, loopsb) { i := add(1, i) } { mstore(add(m, add(mul(32, add(1, i)), alen)), mload(add(b, mul(32, add(1, i))))) }\n            mstore(0x40, add(m, add(32, totallen)))\n            c := m\n        }\n    }\n\n    function bytesToAddress(uint _offst, bytes memory _input) internal pure returns (address) {\n        return BytesToTypes.bytesToAddress(_offst, _input);\n    }\n\n    function bytesToUint256(uint _offst, bytes memory _input) internal pure returns (uint256) {\n        return BytesToTypes.bytesToUint256(_offst, _input);\n    } \n\n}\n"
    },
    "contracts/interface/IAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\ninterface IAdapter {\n    function name() external view returns (string memory);\n    function swap(uint256, uint256, address[] memory) external payable;\n    function swapFromTokenToTokenWithoutTransfer(uint256, address[] memory, uint256, address) external payable;\n    function query(uint256, address, address) external view returns (uint);\n}"
    },
    "contracts/lib/BytesToTypes.sol": {
      "content": "// From https://github.com/pouladzade/Seriality/blob/master/src/BytesToTypes.sol\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\nlibrary BytesToTypes {\n\n    function bytesToAddress(uint _offst, bytes memory _input) internal pure returns (address _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    } \n    \n    function bytesToBool(uint _offst, bytes memory _input) internal pure returns (bool _output) {\n        \n        uint8 x;\n        assembly {\n            x := mload(add(_input, _offst))\n        }\n        x==0 ? _output = false : _output = true;\n    }   \n        \n    function getStringSize(uint _offst, bytes memory _input) internal pure returns(uint size){\n        \n        assembly{\n            \n            size := mload(add(_input,_offst))\n            let chunk_count := add(div(size,32),1) // chunk_count = size/32 + 1\n            \n            if gt(mod(size,32),0) {// if size%32 > 0\n                chunk_count := add(chunk_count,1)\n            } \n            \n             size := mul(chunk_count,32)// first 32 bytes reseves for size in strings\n        }\n    }\n\n    function bytesToString(uint _offst, bytes memory _input, bytes memory _output) internal pure {\n\n        uint size = 32;\n        assembly {\n            \n            let chunk_count\n            \n            size := mload(add(_input,_offst))\n            chunk_count := add(div(size,32),1) // chunk_count = size/32 + 1\n            \n            if gt(mod(size,32),0) {\n                chunk_count := add(chunk_count,1)  // chunk_count++\n            }\n               \n            for { let index:= 0 }  lt(index , chunk_count){ index := add(index,1) } {\n                mstore(add(_output,mul(index,32)),mload(add(_input,_offst)))\n                _offst := sub(_offst,32)           // _offst -= 32\n            }\n        }\n    }\n\n    function bytesToBytes32(uint _offst, bytes memory  _input, bytes32 _output) internal pure {\n        \n        assembly {\n            mstore(_output , add(_input, _offst))\n            mstore(add(_output,32) , add(add(_input, _offst),32))\n        }\n    }\n    \n    function bytesToInt8(uint _offst, bytes memory  _input) internal pure returns (int8 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n    \n    function bytesToInt16(uint _offst, bytes memory _input) internal pure returns (int16 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt24(uint _offst, bytes memory _input) internal pure returns (int24 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt32(uint _offst, bytes memory _input) internal pure returns (int32 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt40(uint _offst, bytes memory _input) internal pure returns (int40 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt48(uint _offst, bytes memory _input) internal pure returns (int48 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt56(uint _offst, bytes memory _input) internal pure returns (int56 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt64(uint _offst, bytes memory _input) internal pure returns (int64 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt72(uint _offst, bytes memory _input) internal pure returns (int72 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt80(uint _offst, bytes memory _input) internal pure returns (int80 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt88(uint _offst, bytes memory _input) internal pure returns (int88 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt96(uint _offst, bytes memory _input) internal pure returns (int96 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\t\n\tfunction bytesToInt104(uint _offst, bytes memory _input) internal pure returns (int104 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n    \n    function bytesToInt112(uint _offst, bytes memory _input) internal pure returns (int112 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt120(uint _offst, bytes memory _input) internal pure returns (int120 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt128(uint _offst, bytes memory _input) internal pure returns (int128 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt136(uint _offst, bytes memory _input) internal pure returns (int136 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt144(uint _offst, bytes memory _input) internal pure returns (int144 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt152(uint _offst, bytes memory _input) internal pure returns (int152 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt160(uint _offst, bytes memory _input) internal pure returns (int160 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt168(uint _offst, bytes memory _input) internal pure returns (int168 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt176(uint _offst, bytes memory _input) internal pure returns (int176 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt184(uint _offst, bytes memory _input) internal pure returns (int184 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt192(uint _offst, bytes memory _input) internal pure returns (int192 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt200(uint _offst, bytes memory _input) internal pure returns (int200 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt208(uint _offst, bytes memory _input) internal pure returns (int208 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt216(uint _offst, bytes memory _input) internal pure returns (int216 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt224(uint _offst, bytes memory _input) internal pure returns (int224 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt232(uint _offst, bytes memory _input) internal pure returns (int232 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt240(uint _offst, bytes memory _input) internal pure returns (int240 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt248(uint _offst, bytes memory _input) internal pure returns (int248 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n    function bytesToInt256(uint _offst, bytes memory _input) internal pure returns (int256 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    }\n\n\tfunction bytesToUint8(uint _offst, bytes memory _input) internal pure returns (uint8 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    } \n\n\tfunction bytesToUint16(uint _offst, bytes memory _input) internal pure returns (uint16 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    } \n\n\tfunction bytesToUint24(uint _offst, bytes memory _input) internal pure returns (uint24 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    } \n\n\tfunction bytesToUint32(uint _offst, bytes memory _input) internal pure returns (uint32 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    } \n\n\tfunction bytesToUint40(uint _offst, bytes memory _input) internal pure returns (uint40 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    } \n\n\tfunction bytesToUint48(uint _offst, bytes memory _input) internal pure returns (uint48 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    } \n\n\tfunction bytesToUint56(uint _offst, bytes memory _input) internal pure returns (uint56 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    } \n\n\tfunction bytesToUint64(uint _offst, bytes memory _input) internal pure returns (uint64 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    } \n\n\tfunction bytesToUint72(uint _offst, bytes memory _input) internal pure returns (uint72 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    } \n\n\tfunction bytesToUint80(uint _offst, bytes memory _input) internal pure returns (uint80 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    } \n\n\tfunction bytesToUint88(uint _offst, bytes memory _input) internal pure returns (uint88 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    } \n\n\tfunction bytesToUint96(uint _offst, bytes memory _input) internal pure returns (uint96 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    } \n\t\n\tfunction bytesToUint104(uint _offst, bytes memory _input) internal pure returns (uint104 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    } \n\n    function bytesToUint112(uint _offst, bytes memory _input) internal pure returns (uint112 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    } \n\n    function bytesToUint120(uint _offst, bytes memory _input) internal pure returns (uint120 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    } \n\n    function bytesToUint128(uint _offst, bytes memory _input) internal pure returns (uint128 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    } \n\n    function bytesToUint136(uint _offst, bytes memory _input) internal pure returns (uint136 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    } \n\n    function bytesToUint144(uint _offst, bytes memory _input) internal pure returns (uint144 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    } \n\n    function bytesToUint152(uint _offst, bytes memory _input) internal pure returns (uint152 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    } \n\n    function bytesToUint160(uint _offst, bytes memory _input) internal pure returns (uint160 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    } \n\n    function bytesToUint168(uint _offst, bytes memory _input) internal pure returns (uint168 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    } \n\n    function bytesToUint176(uint _offst, bytes memory _input) internal pure returns (uint176 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    } \n\n    function bytesToUint184(uint _offst, bytes memory _input) internal pure returns (uint184 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    } \n\n    function bytesToUint192(uint _offst, bytes memory _input) internal pure returns (uint192 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    } \n\n    function bytesToUint200(uint _offst, bytes memory _input) internal pure returns (uint200 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    } \n\n    function bytesToUint208(uint _offst, bytes memory _input) internal pure returns (uint208 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    } \n\n    function bytesToUint216(uint _offst, bytes memory _input) internal pure returns (uint216 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    } \n\n    function bytesToUint224(uint _offst, bytes memory _input) internal pure returns (uint224 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    } \n\n    function bytesToUint232(uint _offst, bytes memory _input) internal pure returns (uint232 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    } \n\n    function bytesToUint240(uint _offst, bytes memory _input) internal pure returns (uint240 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    } \n\n    function bytesToUint248(uint _offst, bytes memory _input) internal pure returns (uint248 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    } \n\n    function bytesToUint256(uint _offst, bytes memory _input) internal pure returns (uint256 _output) {\n        \n        assembly {\n            _output := mload(add(_input, _offst))\n        }\n    } \n}\n"
    },
    "contracts/adapters/PangolinAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\nimport \"../interface/IUnilikeAVAXRouter.sol\";\nimport \"../interface/IWETH.sol\";\nimport \"../interface/IERC20.sol\";\nimport \"../YakAdapter.sol\";\n\ncontract PangolinAdapter is YakAdapter {\n\n    constructor (string memory _name, address _router) {\n        name = _name;\n        router = _router;\n        setAllowances();\n    }\n\n    function setAllowances() public override onlyOwner {\n        IERC20(WAVAX).approve(WAVAX, UINT_MAX);\n    }\n\n    function query(uint amountIn, address tokenIn, address tokenOut) external override view returns (uint) {\n        address[] memory path = new address[](2);\n        path[0] = tokenIn;\n        path[1] = tokenOut;\n        if (tokenIn == tokenOut) { return 0; }\n        try IUnilikeAVAXRouter(router).getAmountsOut(\n            amountIn, path\n        ) returns (uint[] memory amounts) {\n            return amounts[1];\n        } catch {\n            return 0;\n        }\n    }\n\n    function _swap(uint amountIn, address[] calldata path, uint amountOutMin) internal override {\n        IUnilikeAVAXRouter(router).swapExactTokensForTokens(\n            amountIn,\n            amountOutMin,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n}"
    },
    "contracts/interface/IUnilikeAVAXRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\ninterface IUnilikeAVAXRouter {\n    \n    function factory() external pure returns (address);\n    function WAVAX() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityAVAX(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountAVAXMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountAVAX, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityAVAX(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountAVAXMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountAVAX);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityAVAXWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountAVAXMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountAVAX);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactAVAXForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactAVAX(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForAVAX(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapAVAXForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n\n    function removeLiquidityAVAXSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountAVAXMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountAVAX);\n    function removeLiquidityAVAXWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountAVAXMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountAVAX);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactAVAXForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForAVAXSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 999
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}